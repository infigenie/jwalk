// +build ignore

// This program generates value.go.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
)

const header = `// Code generated by go run make_value.go. DO NOT EDIT.
package jwalk

import (
	"github.com/mailru/easyjson/jlexer"
)

`

func main() {
	w := bytes.NewBuffer([]byte(header))

	fns := []struct {
		name string
		ret  string
	}{
		{"Bytes", "[]byte"},
		{"String", "string"},
		{"Int8", "int8"},
		{"Int16", "int16"},
		{"Int32", "int32"},
		{"Int64", "int64"},
		{"Int", "int"},
		{"Uint", "uint"},
		{"Uint8", "uint8"},
		{"Uint16", "uint16"},
		{"Uint32", "uint32"},
		{"Uint64", "uint64"},
		{"Float32", "float32"},
		{"Float64", "float64"},
		{"Interface", "interface{}"},
	}

	fmt.Fprint(w, "type Value interface {\n")
	for _, f := range fns {
		fmt.Fprintf(w, "\t%s() %s\n", f.name, f.ret)
	}
	fmt.Fprint(w, "}\n\n")
	fmt.Fprint(w, "type value struct {\n\traw []byte\n}\n\n")
	fmt.Fprint(w, "func (v value) MarshalJSON() ([]byte, error) {\n\treturn v.raw, nil\n}\n\n")
	for _, f := range fns {
		fmt.Fprintf(w, "func (v value) %s() %s {\n", f.name, f.ret)
		fmt.Fprintf(w, "\tl := &jlexer.Lexer{Data: v.raw}\n\treturn l.%s()\n", f.name)
		fmt.Fprint(w, "}\n\n")
	}

	if err := ioutil.WriteFile("value.go", w.Bytes(), 0666); err != nil {
		log.Fatal(err)
	}
}
